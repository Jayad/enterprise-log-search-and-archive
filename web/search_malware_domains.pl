#!/usr/bin/perl
use strict;
use Data::Dumper;
use LWP::UserAgent;
use Term::ProgressBar;
use POE::Event::Message;
use IO::Socket;
use Mail::Internet;
use JSON;
use FindBin;
use URI;

use lib $FindBin::Bin . '/lib';

use Janus;

my $Ignore_domains = {
	'rapidshare.com' => 1,
};

my $ua       = new LWP::UserAgent;
my $janus = new Janus("/etc/janus.conf");

# Verify that we've got settings
unless ($janus and $janus->conf->get('search_malware_domains')){
	die('No config found for search_malware_domains in janus.conf');
}

$janus->log->level('ERROR');

my $interval = 3600;
my $start_time = time() - $interval;
my $end_time = time();

my $query_meta_params = {
	start => $start_time,
	end => $end_time,
};

my $lists = {
	#'malwaredomainlist' => \&get_malwaredomainlist,
	'malwaredomainlist_zeus' => \&get_malwaredomainlist_zeus,
	'zeustracker' => \&get_zeustracker,
	'get_malware_dot_com_dot_br' => \&get_malware_dot_com_dot_br,
	'get_amada' => \&get_amada,
	'get_spyeye' => \&get_spyeyetracker,
};

my %uniq_list;
my $list = [];
foreach my $list_name (keys %$lists){
	foreach my $item (@{ $lists->{$list_name}->() }){
		next if $uniq_list{$item};
		push @$list, $item;
		$uniq_list{$item} = 1;
	}
}
$list = batchify($list);

my $progress = 0;
# Are we interactive?
if (-t STDIN && -t STDOUT){
	$progress = Term::ProgressBar->new ({count => scalar @$list, ETA => 'linear'});
}

my %matches;
my $overall = 0;
my $total_found = 0;
print 'Searching...' . "\n" if $progress;

# Get username
my $msg = POE::Event::Message->package('system');
$msg->addRouteTo('post',  $janus->conf->get('Janus/session'), 'get_user_info');
$msg->addRemoteRouteTo($janus->conf->get('Janus/server'), $janus->conf->get('Janus/port'), 'sync');
$msg->setMode('call');
my ($ret) = $msg->route();
my $user = $ret->body();

my @content;
foreach my $batch (@$list) {
	$overall++;
	my $params = { q => encode_json({
		query_params => join(' ', @$batch), 
		query_meta_params => $query_meta_params,
	})};
	my $msg = POE::Event::Message->package($params);
	$msg->param('_user', $user);
	$msg->addRouteTo('post',  $janus->conf->get('Janus/session'), 'query');
	$msg->addRemoteRouteTo($janus->conf->get('Janus/server'), $janus->conf->get('Janus/port'), 'sync');
	$msg->setMode('call');
	my ($ret) = $msg->route();
	if ($ret and ref($ret) and $ret->can('body') and $ret->body() and scalar @{ $ret->body()->{results} }){
		push @content, @{ $ret->body()->{results} };
	}
	
	$progress->update($overall) if $progress;
}

my %uniq;
foreach my $row (@content){
	if ($uniq{ $row->{msg} }){
		$uniq{ $row->{msg} }->{last} = $row->{timestamp};
		$uniq{ $row->{msg} }->{count}++;
	}
	else {
		$uniq{ $row->{msg} } = { first => $row->{timestamp}, count => 1 };
	}
}

if (scalar keys %uniq){
	my $body = 'Results for Zeus Searches:' . "\r\n";
	foreach my $msg (sort { $uniq{$a}->{first} <=> $uniq{$b}->{first} } keys %uniq){
		if ($uniq{$msg}->{count} > 1){
			$body .= $uniq{$msg}->{count} . ' times from ' . $uniq{$msg}->{first} . ' to ' . $uniq{$msg}->{last} . ' ' . $msg . "\r\n";
		}
		else {
			$body .= $uniq{$msg}->{first} . ' ' . $msg . "\r\n";
		}  
	}
	
	# Send the email
	unless ($janus->conf->get('search_malware_domains/email')
		and $janus->conf->get('search_malware_domains/email/to')
		and $janus->conf->get('search_malware_domains/email/from')){
		die('Invalid email configuration in conf file');
	}
	my $headers = {
		To => $janus->conf->get('search_malware_domains/email/to'),
		From => $janus->conf->get('search_malware_domains/email/from'),
		Subject => (scalar keys %uniq) . ' ' . $janus->conf->get('search_malware_domains/email/subject'),
	};
	my $email_headers = new Mail::Header();
	$email_headers->header_hashref($headers);
	my $email = new Mail::Internet( Header => $email_headers, Body => [ split(/\n/, $body) ] );
	
	$email->smtpsend(
		Host => $janus->conf->get('email/smtp_server'), 
		Debug => 0, 
		MailFrom => $janus->conf->get('search_malware_domains/email/from_label') ? 
			$janus->conf->get('search_malware_domains/email/from_label') : $janus->conf->get('search_malware_domains/email/from'),
	);
}
else {
	print 'No results' . "\n" if $progress;
}

sub get_malwaredomains {
	my $url = q{http://www.malwaredomains.com/files/domains.txt};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	
	my @list;
	foreach my $line (@lines) {
		next if $line =~ /^\s*\#/;
		my @cols = split( /\s+/, $line );
		next if $Ignore_domains->{ $cols[1] };
		push @list, 'URL.domains:"' . $cols[1] . '"';
	}
	return \@list;
}

sub get_malwaredomainlist {
	my $url = q{http://www.malwaredomainlist.com/hostslist/ip.txt};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	
	my @list;
	foreach my $line (@lines) {
		next unless $line =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/;
		push @list, 'URL.dstip:' . $1;
	}
	return \@list;
}

sub get_zeustracker {
	my $url = q{https://zeustracker.abuse.ch/blocklist.php?download=domainblocklist};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	
	my @list;
	foreach my $line (@lines) {
		chomp($line);
		next if $line =~ /^\s*#/;
		next unless $line =~ /.\../;
		next if $Ignore_domains->{$line};
		push @list, 'URL.site:' . $line;
	}
	return \@list;
}

sub get_spyeyetracker {
	my $url = q{https://spyeyetracker.abuse.ch/blocklist.php?download=domainblocklist};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	
	my @list;
	foreach my $line (@lines) {
		chomp($line);
		next if $line =~ /^\s*#/;
		next unless $line =~ /.\../;
		next if $Ignore_domains->{$line};
		push @list, 'URL.site:' . $line;
	}
	return \@list;
}


sub get_amada {
	my $url = q{http://amada.abuse.ch/blocklist.php?download=domainblocklist};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	
	my @list;
	foreach my $line (@lines) {
		chomp($line);
		next if $line =~ /^\s*#/;
		next unless $line =~ /.\../;
		$line =~ /^([\w\.\-]+)\ \#\ (.+)/;
		my ($url, $malware_name) = ($1, $2);
		next if $Ignore_domains->{$url};
		#print 'URL.site:' . $url . ', name: ' . $malware_name . "\n";
		push @list, 'URL.site:' . $url;
	}
	return \@list;
}

sub get_malwaredomainlist_zeus {
	my $url = q{http://www.malwaredomainlist.com/zeuscsv.php};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	
	my @list;
	foreach my $line (@lines) {
		chomp($line);
		next if $line =~ /^\s*#/;
		next unless $line =~ /.\../;
		my ($date, $full_url, $ip_url, $hostname, $description) = split(/,/, $line);
		$full_url =~ s/\"//g;
		my ($short_url, $uri) = split(/\//, $full_url);
		if ($short_url ne '-'){
			next if $Ignore_domains->{ $short_url };
			push @list, 'URL.site:' . $short_url;
		}
		else {
			my ($ip_port, $ip_uri) = split(/\//, $ip_url);
			$ip_port =~ s/\"//g;
			my ($ip, $port) = split(/:/, $ip_port);
			push @list, 'URL.dstip:' . $ip;	
		}
	}
	#print Dumper(\@list);
	return \@list;
}

sub get_malware_dot_com_dot_br {
	my $url = q{http://www.malware.com.br/cgi/submit-agressive?action=list&type=normal};
	my $response = $ua->get($url);
	my @lines    = split( /\n/, $response->decoded_content() );
	return [] unless scalar @lines;
	my @list;
	foreach my $line (@lines) {
		chomp($line);
		next if $line =~ /^\s*#/;
		next unless $line =~ /^https?:\/\//;
		my $uri = new URI($line);
		my @uri_parts = split(/\//, $uri->path());
		shift(@uri_parts); # remove the initial slash
		my $uri_search = join(' ', map { ' +URL.uri:' . $_ } @uri_parts);
		push @list, '(+URL.site:' . $uri->host() . ' ' . $uri_search . ')';
	}
	return \@list;
}

sub batchify {
	my $list = shift;
	my @batches;
	my @tmp;
	my $counter = 0;
	foreach my $item (@$list) {
		push @tmp, $item;
	
		if ( $counter >= 31 ) {
			push @batches, [@tmp];
			$counter = 0;
			@tmp     = ();
		}
		else {
			$counter++;
	
			if ( $counter == ( scalar @$list ) ) {
				push @batches, [@tmp];
			}
		}
	}
	return \@batches;
}